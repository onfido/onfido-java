/*
 * Onfido API v3.6
 * The Onfido API
 *
 * The version of the OpenAPI document: 3.6.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.onfido.model;

import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import com.onfido.model.DeviceIntelligenceReport;
import com.onfido.model.DocumentReport;
import com.onfido.model.DocumentVideoReport;
import com.onfido.model.DocumentVideoWithAddressInformationReport;
import com.onfido.model.DocumentWithAddressInformationReport;
import com.onfido.model.DocumentWithDriverVerificationReport;
import com.onfido.model.DocumentWithDrivingLicenceInformationReport;
import com.onfido.model.FacialSimilarityMotionReport;
import com.onfido.model.FacialSimilarityPhotoFullyAutoReport;
import com.onfido.model.FacialSimilarityPhotoReport;
import com.onfido.model.FacialSimilarityVideoReport;
import com.onfido.model.IdentityEnhancedReport;
import com.onfido.model.IndiaPanReport;
import com.onfido.model.IndiaPanReportAllOfBreakdown;
import com.onfido.model.IndiaPanReportAllOfProperties;
import com.onfido.model.KnownFacesReport;
import com.onfido.model.ProofOfAddressReport;
import com.onfido.model.ReportDocument;
import com.onfido.model.ReportName;
import com.onfido.model.ReportResult;
import com.onfido.model.ReportStatus;
import com.onfido.model.ReportSubResult;
import com.onfido.model.UsDrivingLicenceReport;
import com.onfido.model.WatchlistAmlReport;
import com.onfido.model.WatchlistEnhancedReport;
import com.onfido.model.WatchlistPepsOnlyReport;
import com.onfido.model.WatchlistSanctionsOnlyReport;
import com.onfido.model.WatchlistStandardReport;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.onfido.JSON;

import com.fasterxml.jackson.core.type.TypeReference;

import javax.ws.rs.core.GenericType;
import javax.ws.rs.core.Response;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.MapperFeature;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
import com.fasterxml.jackson.databind.ser.std.StdSerializer;
import com.onfido.JSON;

@com.fasterxml.jackson.annotation.JsonIgnoreProperties(ignoreUnknown = true)
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.4.0")
@JsonDeserialize(using = Report.ReportDeserializer.class)
@JsonSerialize(using = Report.ReportSerializer.class)
public class Report extends AbstractOpenApiSchema {
    private static final Logger log = Logger.getLogger(Report.class.getName());

    public static class ReportSerializer extends StdSerializer<Report> {
        public ReportSerializer(Class<Report> t) {
            super(t);
        }

        public ReportSerializer() {
            this(null);
        }

        @Override
        public void serialize(Report value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException {
            jgen.writeObject(value.getActualInstance());
        }
    }

    public static class ReportDeserializer extends StdDeserializer<Report> {
        public ReportDeserializer() {
            this(Report.class);
        }

        public ReportDeserializer(Class<?> vc) {
            super(vc);
        }

        @Override
        public Report deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {
            JsonNode tree = jp.readValueAsTree();
            Object deserialized = null;
            Report newReport = new Report();
            Map<String, Object> result2 = tree.traverse(jp.getCodec()).readValueAs(new TypeReference<Map<String, Object>>() {});
            String discriminatorValue = (String)result2.get("name");
            switch (discriminatorValue) {
                case "device_intelligence":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(DeviceIntelligenceReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "document":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(DocumentReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "document_video":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(DocumentVideoReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "document_video_with_address_information":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(DocumentVideoWithAddressInformationReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "document_with_address_information":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(DocumentWithAddressInformationReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "document_with_driver_verification":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(DocumentWithDriverVerificationReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "document_with_driving_licence_information":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(DocumentWithDrivingLicenceInformationReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "facial_similarity_motion":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(FacialSimilarityMotionReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "facial_similarity_photo":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(FacialSimilarityPhotoReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "facial_similarity_photo_fully_auto":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(FacialSimilarityPhotoFullyAutoReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "facial_similarity_video":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(FacialSimilarityVideoReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "identity_enhanced":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(IdentityEnhancedReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "india_pan":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(IndiaPanReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "known_faces":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(KnownFacesReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "proof_of_address":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(ProofOfAddressReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "us_driving_licence":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(UsDrivingLicenceReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "watchlist_aml":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(WatchlistAmlReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "watchlist_enhanced":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(WatchlistEnhancedReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "watchlist_peps_only":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(WatchlistPepsOnlyReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "watchlist_sanctions_only":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(WatchlistSanctionsOnlyReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "watchlist_standard":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(WatchlistStandardReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "device_intelligence_report":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(DeviceIntelligenceReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "document_report":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(DocumentReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "document_video_report":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(DocumentVideoReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "document_video_with_address_information_report":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(DocumentVideoWithAddressInformationReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "document_with_address_information_report":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(DocumentWithAddressInformationReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "document_with_driver_verification_report":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(DocumentWithDriverVerificationReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "document_with_driving_licence_information_report":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(DocumentWithDrivingLicenceInformationReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "facial_similarity_motion_report":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(FacialSimilarityMotionReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "facial_similarity_photo_fully_auto_report":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(FacialSimilarityPhotoFullyAutoReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "facial_similarity_photo_report":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(FacialSimilarityPhotoReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "facial_similarity_video_report":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(FacialSimilarityVideoReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "identity_enhanced_report":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(IdentityEnhancedReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "india_pan_report":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(IndiaPanReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "known_faces_report":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(KnownFacesReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "proof_of_address_report":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(ProofOfAddressReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "us_driving_licence_report":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(UsDrivingLicenceReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "watchlist_aml_report":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(WatchlistAmlReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "watchlist_enhanced_report":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(WatchlistEnhancedReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "watchlist_peps_only_report":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(WatchlistPepsOnlyReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "watchlist_sanctions_only_report":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(WatchlistSanctionsOnlyReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                case "watchlist_standard_report":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(WatchlistStandardReport.class);
                    newReport.setActualInstance(deserialized);
                    return newReport;
                default:
                    log.log(Level.WARNING, String.format("Failed to lookup discriminator value `%s` for Report. Possible values: device_intelligence document document_video document_video_with_address_information document_with_address_information document_with_driver_verification document_with_driving_licence_information facial_similarity_motion facial_similarity_photo facial_similarity_photo_fully_auto facial_similarity_video identity_enhanced india_pan known_faces proof_of_address us_driving_licence watchlist_aml watchlist_enhanced watchlist_peps_only watchlist_sanctions_only watchlist_standard device_intelligence_report document_report document_video_report document_video_with_address_information_report document_with_address_information_report document_with_driver_verification_report document_with_driving_licence_information_report facial_similarity_motion_report facial_similarity_photo_fully_auto_report facial_similarity_photo_report facial_similarity_video_report identity_enhanced_report india_pan_report known_faces_report proof_of_address_report us_driving_licence_report watchlist_aml_report watchlist_enhanced_report watchlist_peps_only_report watchlist_sanctions_only_report watchlist_standard_report", discriminatorValue));
            }

            boolean typeCoercion = ctxt.isEnabled(MapperFeature.ALLOW_COERCION_OF_SCALARS);
            int match = 0;
            JsonToken token = tree.traverse(jp.getCodec()).nextToken();
            // deserialize DeviceIntelligenceReport
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (DeviceIntelligenceReport.class.equals(Integer.class) || DeviceIntelligenceReport.class.equals(Long.class) || DeviceIntelligenceReport.class.equals(Float.class) || DeviceIntelligenceReport.class.equals(Double.class) || DeviceIntelligenceReport.class.equals(Boolean.class) || DeviceIntelligenceReport.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((DeviceIntelligenceReport.class.equals(Integer.class) || DeviceIntelligenceReport.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((DeviceIntelligenceReport.class.equals(Float.class) || DeviceIntelligenceReport.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (DeviceIntelligenceReport.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (DeviceIntelligenceReport.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(DeviceIntelligenceReport.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'DeviceIntelligenceReport'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'DeviceIntelligenceReport'", e);
            }

            // deserialize DocumentReport
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (DocumentReport.class.equals(Integer.class) || DocumentReport.class.equals(Long.class) || DocumentReport.class.equals(Float.class) || DocumentReport.class.equals(Double.class) || DocumentReport.class.equals(Boolean.class) || DocumentReport.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((DocumentReport.class.equals(Integer.class) || DocumentReport.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((DocumentReport.class.equals(Float.class) || DocumentReport.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (DocumentReport.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (DocumentReport.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(DocumentReport.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'DocumentReport'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'DocumentReport'", e);
            }

            // deserialize DocumentVideoReport
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (DocumentVideoReport.class.equals(Integer.class) || DocumentVideoReport.class.equals(Long.class) || DocumentVideoReport.class.equals(Float.class) || DocumentVideoReport.class.equals(Double.class) || DocumentVideoReport.class.equals(Boolean.class) || DocumentVideoReport.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((DocumentVideoReport.class.equals(Integer.class) || DocumentVideoReport.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((DocumentVideoReport.class.equals(Float.class) || DocumentVideoReport.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (DocumentVideoReport.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (DocumentVideoReport.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(DocumentVideoReport.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'DocumentVideoReport'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'DocumentVideoReport'", e);
            }

            // deserialize DocumentVideoWithAddressInformationReport
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (DocumentVideoWithAddressInformationReport.class.equals(Integer.class) || DocumentVideoWithAddressInformationReport.class.equals(Long.class) || DocumentVideoWithAddressInformationReport.class.equals(Float.class) || DocumentVideoWithAddressInformationReport.class.equals(Double.class) || DocumentVideoWithAddressInformationReport.class.equals(Boolean.class) || DocumentVideoWithAddressInformationReport.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((DocumentVideoWithAddressInformationReport.class.equals(Integer.class) || DocumentVideoWithAddressInformationReport.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((DocumentVideoWithAddressInformationReport.class.equals(Float.class) || DocumentVideoWithAddressInformationReport.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (DocumentVideoWithAddressInformationReport.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (DocumentVideoWithAddressInformationReport.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(DocumentVideoWithAddressInformationReport.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'DocumentVideoWithAddressInformationReport'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'DocumentVideoWithAddressInformationReport'", e);
            }

            // deserialize DocumentWithAddressInformationReport
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (DocumentWithAddressInformationReport.class.equals(Integer.class) || DocumentWithAddressInformationReport.class.equals(Long.class) || DocumentWithAddressInformationReport.class.equals(Float.class) || DocumentWithAddressInformationReport.class.equals(Double.class) || DocumentWithAddressInformationReport.class.equals(Boolean.class) || DocumentWithAddressInformationReport.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((DocumentWithAddressInformationReport.class.equals(Integer.class) || DocumentWithAddressInformationReport.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((DocumentWithAddressInformationReport.class.equals(Float.class) || DocumentWithAddressInformationReport.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (DocumentWithAddressInformationReport.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (DocumentWithAddressInformationReport.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(DocumentWithAddressInformationReport.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'DocumentWithAddressInformationReport'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'DocumentWithAddressInformationReport'", e);
            }

            // deserialize DocumentWithDriverVerificationReport
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (DocumentWithDriverVerificationReport.class.equals(Integer.class) || DocumentWithDriverVerificationReport.class.equals(Long.class) || DocumentWithDriverVerificationReport.class.equals(Float.class) || DocumentWithDriverVerificationReport.class.equals(Double.class) || DocumentWithDriverVerificationReport.class.equals(Boolean.class) || DocumentWithDriverVerificationReport.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((DocumentWithDriverVerificationReport.class.equals(Integer.class) || DocumentWithDriverVerificationReport.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((DocumentWithDriverVerificationReport.class.equals(Float.class) || DocumentWithDriverVerificationReport.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (DocumentWithDriverVerificationReport.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (DocumentWithDriverVerificationReport.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(DocumentWithDriverVerificationReport.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'DocumentWithDriverVerificationReport'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'DocumentWithDriverVerificationReport'", e);
            }

            // deserialize DocumentWithDrivingLicenceInformationReport
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (DocumentWithDrivingLicenceInformationReport.class.equals(Integer.class) || DocumentWithDrivingLicenceInformationReport.class.equals(Long.class) || DocumentWithDrivingLicenceInformationReport.class.equals(Float.class) || DocumentWithDrivingLicenceInformationReport.class.equals(Double.class) || DocumentWithDrivingLicenceInformationReport.class.equals(Boolean.class) || DocumentWithDrivingLicenceInformationReport.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((DocumentWithDrivingLicenceInformationReport.class.equals(Integer.class) || DocumentWithDrivingLicenceInformationReport.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((DocumentWithDrivingLicenceInformationReport.class.equals(Float.class) || DocumentWithDrivingLicenceInformationReport.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (DocumentWithDrivingLicenceInformationReport.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (DocumentWithDrivingLicenceInformationReport.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(DocumentWithDrivingLicenceInformationReport.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'DocumentWithDrivingLicenceInformationReport'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'DocumentWithDrivingLicenceInformationReport'", e);
            }

            // deserialize FacialSimilarityMotionReport
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (FacialSimilarityMotionReport.class.equals(Integer.class) || FacialSimilarityMotionReport.class.equals(Long.class) || FacialSimilarityMotionReport.class.equals(Float.class) || FacialSimilarityMotionReport.class.equals(Double.class) || FacialSimilarityMotionReport.class.equals(Boolean.class) || FacialSimilarityMotionReport.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((FacialSimilarityMotionReport.class.equals(Integer.class) || FacialSimilarityMotionReport.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((FacialSimilarityMotionReport.class.equals(Float.class) || FacialSimilarityMotionReport.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (FacialSimilarityMotionReport.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (FacialSimilarityMotionReport.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(FacialSimilarityMotionReport.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'FacialSimilarityMotionReport'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'FacialSimilarityMotionReport'", e);
            }

            // deserialize FacialSimilarityPhotoFullyAutoReport
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (FacialSimilarityPhotoFullyAutoReport.class.equals(Integer.class) || FacialSimilarityPhotoFullyAutoReport.class.equals(Long.class) || FacialSimilarityPhotoFullyAutoReport.class.equals(Float.class) || FacialSimilarityPhotoFullyAutoReport.class.equals(Double.class) || FacialSimilarityPhotoFullyAutoReport.class.equals(Boolean.class) || FacialSimilarityPhotoFullyAutoReport.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((FacialSimilarityPhotoFullyAutoReport.class.equals(Integer.class) || FacialSimilarityPhotoFullyAutoReport.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((FacialSimilarityPhotoFullyAutoReport.class.equals(Float.class) || FacialSimilarityPhotoFullyAutoReport.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (FacialSimilarityPhotoFullyAutoReport.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (FacialSimilarityPhotoFullyAutoReport.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(FacialSimilarityPhotoFullyAutoReport.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'FacialSimilarityPhotoFullyAutoReport'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'FacialSimilarityPhotoFullyAutoReport'", e);
            }

            // deserialize FacialSimilarityPhotoReport
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (FacialSimilarityPhotoReport.class.equals(Integer.class) || FacialSimilarityPhotoReport.class.equals(Long.class) || FacialSimilarityPhotoReport.class.equals(Float.class) || FacialSimilarityPhotoReport.class.equals(Double.class) || FacialSimilarityPhotoReport.class.equals(Boolean.class) || FacialSimilarityPhotoReport.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((FacialSimilarityPhotoReport.class.equals(Integer.class) || FacialSimilarityPhotoReport.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((FacialSimilarityPhotoReport.class.equals(Float.class) || FacialSimilarityPhotoReport.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (FacialSimilarityPhotoReport.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (FacialSimilarityPhotoReport.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(FacialSimilarityPhotoReport.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'FacialSimilarityPhotoReport'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'FacialSimilarityPhotoReport'", e);
            }

            // deserialize FacialSimilarityVideoReport
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (FacialSimilarityVideoReport.class.equals(Integer.class) || FacialSimilarityVideoReport.class.equals(Long.class) || FacialSimilarityVideoReport.class.equals(Float.class) || FacialSimilarityVideoReport.class.equals(Double.class) || FacialSimilarityVideoReport.class.equals(Boolean.class) || FacialSimilarityVideoReport.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((FacialSimilarityVideoReport.class.equals(Integer.class) || FacialSimilarityVideoReport.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((FacialSimilarityVideoReport.class.equals(Float.class) || FacialSimilarityVideoReport.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (FacialSimilarityVideoReport.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (FacialSimilarityVideoReport.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(FacialSimilarityVideoReport.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'FacialSimilarityVideoReport'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'FacialSimilarityVideoReport'", e);
            }

            // deserialize IdentityEnhancedReport
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (IdentityEnhancedReport.class.equals(Integer.class) || IdentityEnhancedReport.class.equals(Long.class) || IdentityEnhancedReport.class.equals(Float.class) || IdentityEnhancedReport.class.equals(Double.class) || IdentityEnhancedReport.class.equals(Boolean.class) || IdentityEnhancedReport.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((IdentityEnhancedReport.class.equals(Integer.class) || IdentityEnhancedReport.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((IdentityEnhancedReport.class.equals(Float.class) || IdentityEnhancedReport.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (IdentityEnhancedReport.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (IdentityEnhancedReport.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(IdentityEnhancedReport.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'IdentityEnhancedReport'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'IdentityEnhancedReport'", e);
            }

            // deserialize IndiaPanReport
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (IndiaPanReport.class.equals(Integer.class) || IndiaPanReport.class.equals(Long.class) || IndiaPanReport.class.equals(Float.class) || IndiaPanReport.class.equals(Double.class) || IndiaPanReport.class.equals(Boolean.class) || IndiaPanReport.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((IndiaPanReport.class.equals(Integer.class) || IndiaPanReport.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((IndiaPanReport.class.equals(Float.class) || IndiaPanReport.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (IndiaPanReport.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (IndiaPanReport.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(IndiaPanReport.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'IndiaPanReport'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'IndiaPanReport'", e);
            }

            // deserialize KnownFacesReport
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (KnownFacesReport.class.equals(Integer.class) || KnownFacesReport.class.equals(Long.class) || KnownFacesReport.class.equals(Float.class) || KnownFacesReport.class.equals(Double.class) || KnownFacesReport.class.equals(Boolean.class) || KnownFacesReport.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((KnownFacesReport.class.equals(Integer.class) || KnownFacesReport.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((KnownFacesReport.class.equals(Float.class) || KnownFacesReport.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (KnownFacesReport.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (KnownFacesReport.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(KnownFacesReport.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'KnownFacesReport'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'KnownFacesReport'", e);
            }

            // deserialize ProofOfAddressReport
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (ProofOfAddressReport.class.equals(Integer.class) || ProofOfAddressReport.class.equals(Long.class) || ProofOfAddressReport.class.equals(Float.class) || ProofOfAddressReport.class.equals(Double.class) || ProofOfAddressReport.class.equals(Boolean.class) || ProofOfAddressReport.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((ProofOfAddressReport.class.equals(Integer.class) || ProofOfAddressReport.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((ProofOfAddressReport.class.equals(Float.class) || ProofOfAddressReport.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (ProofOfAddressReport.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (ProofOfAddressReport.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(ProofOfAddressReport.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'ProofOfAddressReport'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'ProofOfAddressReport'", e);
            }

            // deserialize UsDrivingLicenceReport
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (UsDrivingLicenceReport.class.equals(Integer.class) || UsDrivingLicenceReport.class.equals(Long.class) || UsDrivingLicenceReport.class.equals(Float.class) || UsDrivingLicenceReport.class.equals(Double.class) || UsDrivingLicenceReport.class.equals(Boolean.class) || UsDrivingLicenceReport.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((UsDrivingLicenceReport.class.equals(Integer.class) || UsDrivingLicenceReport.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((UsDrivingLicenceReport.class.equals(Float.class) || UsDrivingLicenceReport.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (UsDrivingLicenceReport.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (UsDrivingLicenceReport.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(UsDrivingLicenceReport.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'UsDrivingLicenceReport'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'UsDrivingLicenceReport'", e);
            }

            // deserialize WatchlistAmlReport
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (WatchlistAmlReport.class.equals(Integer.class) || WatchlistAmlReport.class.equals(Long.class) || WatchlistAmlReport.class.equals(Float.class) || WatchlistAmlReport.class.equals(Double.class) || WatchlistAmlReport.class.equals(Boolean.class) || WatchlistAmlReport.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((WatchlistAmlReport.class.equals(Integer.class) || WatchlistAmlReport.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((WatchlistAmlReport.class.equals(Float.class) || WatchlistAmlReport.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (WatchlistAmlReport.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (WatchlistAmlReport.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(WatchlistAmlReport.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'WatchlistAmlReport'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'WatchlistAmlReport'", e);
            }

            // deserialize WatchlistEnhancedReport
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (WatchlistEnhancedReport.class.equals(Integer.class) || WatchlistEnhancedReport.class.equals(Long.class) || WatchlistEnhancedReport.class.equals(Float.class) || WatchlistEnhancedReport.class.equals(Double.class) || WatchlistEnhancedReport.class.equals(Boolean.class) || WatchlistEnhancedReport.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((WatchlistEnhancedReport.class.equals(Integer.class) || WatchlistEnhancedReport.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((WatchlistEnhancedReport.class.equals(Float.class) || WatchlistEnhancedReport.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (WatchlistEnhancedReport.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (WatchlistEnhancedReport.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(WatchlistEnhancedReport.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'WatchlistEnhancedReport'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'WatchlistEnhancedReport'", e);
            }

            // deserialize WatchlistPepsOnlyReport
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (WatchlistPepsOnlyReport.class.equals(Integer.class) || WatchlistPepsOnlyReport.class.equals(Long.class) || WatchlistPepsOnlyReport.class.equals(Float.class) || WatchlistPepsOnlyReport.class.equals(Double.class) || WatchlistPepsOnlyReport.class.equals(Boolean.class) || WatchlistPepsOnlyReport.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((WatchlistPepsOnlyReport.class.equals(Integer.class) || WatchlistPepsOnlyReport.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((WatchlistPepsOnlyReport.class.equals(Float.class) || WatchlistPepsOnlyReport.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (WatchlistPepsOnlyReport.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (WatchlistPepsOnlyReport.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(WatchlistPepsOnlyReport.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'WatchlistPepsOnlyReport'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'WatchlistPepsOnlyReport'", e);
            }

            // deserialize WatchlistSanctionsOnlyReport
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (WatchlistSanctionsOnlyReport.class.equals(Integer.class) || WatchlistSanctionsOnlyReport.class.equals(Long.class) || WatchlistSanctionsOnlyReport.class.equals(Float.class) || WatchlistSanctionsOnlyReport.class.equals(Double.class) || WatchlistSanctionsOnlyReport.class.equals(Boolean.class) || WatchlistSanctionsOnlyReport.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((WatchlistSanctionsOnlyReport.class.equals(Integer.class) || WatchlistSanctionsOnlyReport.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((WatchlistSanctionsOnlyReport.class.equals(Float.class) || WatchlistSanctionsOnlyReport.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (WatchlistSanctionsOnlyReport.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (WatchlistSanctionsOnlyReport.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(WatchlistSanctionsOnlyReport.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'WatchlistSanctionsOnlyReport'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'WatchlistSanctionsOnlyReport'", e);
            }

            // deserialize WatchlistStandardReport
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (WatchlistStandardReport.class.equals(Integer.class) || WatchlistStandardReport.class.equals(Long.class) || WatchlistStandardReport.class.equals(Float.class) || WatchlistStandardReport.class.equals(Double.class) || WatchlistStandardReport.class.equals(Boolean.class) || WatchlistStandardReport.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((WatchlistStandardReport.class.equals(Integer.class) || WatchlistStandardReport.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((WatchlistStandardReport.class.equals(Float.class) || WatchlistStandardReport.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (WatchlistStandardReport.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (WatchlistStandardReport.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(WatchlistStandardReport.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'WatchlistStandardReport'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'WatchlistStandardReport'", e);
            }

            if (match == 1) {
                Report ret = new Report();
                ret.setActualInstance(deserialized);
                return ret;
            }
            throw new IOException(String.format("Failed deserialization for Report: %d classes match result, expected 1", match));
        }

        /**
         * Handle deserialization of the 'null' value.
         */
        @Override
        public Report getNullValue(DeserializationContext ctxt) throws JsonMappingException {
            throw new JsonMappingException(ctxt.getParser(), "Report cannot be null");
        }
    }

    // store a list of schema names defined in oneOf
    public static final Map<String, GenericType> schemas = new HashMap<>();

    public Report() {
        super("oneOf", Boolean.FALSE);
    }
  /**
   * A container for additional, undeclared properties.
   * This is a holder for any undeclared properties as specified with
   * the 'additionalProperties' keyword in the OAS document.
   */
  private Map<String, Object> additionalProperties;

  /**
   * Set the additional (undeclared) property with the specified name and value.
   * If the property does not already exist, create it otherwise replace it.
   */
  @JsonAnySetter
  public Report putAdditionalProperty(String key, Object value) {
    if (this.additionalProperties == null) {
        this.additionalProperties = new HashMap<>();
    }
    this.additionalProperties.put(key, value);
    return this;
  }

  /**
   * Return the additional (undeclared) property.
   */
  @JsonAnyGetter
  public Map<String, Object> getAdditionalProperties() {
    return additionalProperties;
  }

  /**
   * Return the additional (undeclared) property with the specified name.
   */
  public Object getAdditionalProperty(String key) {
    if (this.additionalProperties == null) {
        return null;
    }
    return this.additionalProperties.get(key);
  }

    /**
     * Return true if this report object is equal to o.
     */
    @Override
    public boolean equals(Object o) {
        return super.equals(o) && Objects.equals(this.additionalProperties, ((Report)o).additionalProperties);
    }

    @Override
    public int hashCode() {
        return Objects.hash(getActualInstance(), isNullable(), getSchemaType(), additionalProperties);
    }
    public Report(DeviceIntelligenceReport o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public Report(DocumentReport o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public Report(DocumentVideoReport o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public Report(DocumentVideoWithAddressInformationReport o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public Report(DocumentWithAddressInformationReport o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public Report(DocumentWithDriverVerificationReport o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public Report(DocumentWithDrivingLicenceInformationReport o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public Report(FacialSimilarityMotionReport o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public Report(FacialSimilarityPhotoFullyAutoReport o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public Report(FacialSimilarityPhotoReport o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public Report(FacialSimilarityVideoReport o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public Report(IdentityEnhancedReport o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public Report(IndiaPanReport o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public Report(KnownFacesReport o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public Report(ProofOfAddressReport o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public Report(UsDrivingLicenceReport o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public Report(WatchlistAmlReport o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public Report(WatchlistEnhancedReport o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public Report(WatchlistPepsOnlyReport o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public Report(WatchlistSanctionsOnlyReport o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public Report(WatchlistStandardReport o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    static {
        schemas.put("DeviceIntelligenceReport", new GenericType<DeviceIntelligenceReport>() {
        });
        schemas.put("DocumentReport", new GenericType<DocumentReport>() {
        });
        schemas.put("DocumentVideoReport", new GenericType<DocumentVideoReport>() {
        });
        schemas.put("DocumentVideoWithAddressInformationReport", new GenericType<DocumentVideoWithAddressInformationReport>() {
        });
        schemas.put("DocumentWithAddressInformationReport", new GenericType<DocumentWithAddressInformationReport>() {
        });
        schemas.put("DocumentWithDriverVerificationReport", new GenericType<DocumentWithDriverVerificationReport>() {
        });
        schemas.put("DocumentWithDrivingLicenceInformationReport", new GenericType<DocumentWithDrivingLicenceInformationReport>() {
        });
        schemas.put("FacialSimilarityMotionReport", new GenericType<FacialSimilarityMotionReport>() {
        });
        schemas.put("FacialSimilarityPhotoFullyAutoReport", new GenericType<FacialSimilarityPhotoFullyAutoReport>() {
        });
        schemas.put("FacialSimilarityPhotoReport", new GenericType<FacialSimilarityPhotoReport>() {
        });
        schemas.put("FacialSimilarityVideoReport", new GenericType<FacialSimilarityVideoReport>() {
        });
        schemas.put("IdentityEnhancedReport", new GenericType<IdentityEnhancedReport>() {
        });
        schemas.put("IndiaPanReport", new GenericType<IndiaPanReport>() {
        });
        schemas.put("KnownFacesReport", new GenericType<KnownFacesReport>() {
        });
        schemas.put("ProofOfAddressReport", new GenericType<ProofOfAddressReport>() {
        });
        schemas.put("UsDrivingLicenceReport", new GenericType<UsDrivingLicenceReport>() {
        });
        schemas.put("WatchlistAmlReport", new GenericType<WatchlistAmlReport>() {
        });
        schemas.put("WatchlistEnhancedReport", new GenericType<WatchlistEnhancedReport>() {
        });
        schemas.put("WatchlistPepsOnlyReport", new GenericType<WatchlistPepsOnlyReport>() {
        });
        schemas.put("WatchlistSanctionsOnlyReport", new GenericType<WatchlistSanctionsOnlyReport>() {
        });
        schemas.put("WatchlistStandardReport", new GenericType<WatchlistStandardReport>() {
        });
        JSON.registerDescendants(Report.class, Collections.unmodifiableMap(schemas));
        // Initialize and register the discriminator mappings.
        Map<String, Class<?>> mappings = new HashMap<>();
        mappings.put("device_intelligence", DeviceIntelligenceReport.class);
        mappings.put("document", DocumentReport.class);
        mappings.put("document_video", DocumentVideoReport.class);
        mappings.put("document_video_with_address_information", DocumentVideoWithAddressInformationReport.class);
        mappings.put("document_with_address_information", DocumentWithAddressInformationReport.class);
        mappings.put("document_with_driver_verification", DocumentWithDriverVerificationReport.class);
        mappings.put("document_with_driving_licence_information", DocumentWithDrivingLicenceInformationReport.class);
        mappings.put("facial_similarity_motion", FacialSimilarityMotionReport.class);
        mappings.put("facial_similarity_photo", FacialSimilarityPhotoReport.class);
        mappings.put("facial_similarity_photo_fully_auto", FacialSimilarityPhotoFullyAutoReport.class);
        mappings.put("facial_similarity_video", FacialSimilarityVideoReport.class);
        mappings.put("identity_enhanced", IdentityEnhancedReport.class);
        mappings.put("india_pan", IndiaPanReport.class);
        mappings.put("known_faces", KnownFacesReport.class);
        mappings.put("proof_of_address", ProofOfAddressReport.class);
        mappings.put("us_driving_licence", UsDrivingLicenceReport.class);
        mappings.put("watchlist_aml", WatchlistAmlReport.class);
        mappings.put("watchlist_enhanced", WatchlistEnhancedReport.class);
        mappings.put("watchlist_peps_only", WatchlistPepsOnlyReport.class);
        mappings.put("watchlist_sanctions_only", WatchlistSanctionsOnlyReport.class);
        mappings.put("watchlist_standard", WatchlistStandardReport.class);
        mappings.put("device_intelligence_report", DeviceIntelligenceReport.class);
        mappings.put("document_report", DocumentReport.class);
        mappings.put("document_video_report", DocumentVideoReport.class);
        mappings.put("document_video_with_address_information_report", DocumentVideoWithAddressInformationReport.class);
        mappings.put("document_with_address_information_report", DocumentWithAddressInformationReport.class);
        mappings.put("document_with_driver_verification_report", DocumentWithDriverVerificationReport.class);
        mappings.put("document_with_driving_licence_information_report", DocumentWithDrivingLicenceInformationReport.class);
        mappings.put("facial_similarity_motion_report", FacialSimilarityMotionReport.class);
        mappings.put("facial_similarity_photo_fully_auto_report", FacialSimilarityPhotoFullyAutoReport.class);
        mappings.put("facial_similarity_photo_report", FacialSimilarityPhotoReport.class);
        mappings.put("facial_similarity_video_report", FacialSimilarityVideoReport.class);
        mappings.put("identity_enhanced_report", IdentityEnhancedReport.class);
        mappings.put("india_pan_report", IndiaPanReport.class);
        mappings.put("known_faces_report", KnownFacesReport.class);
        mappings.put("proof_of_address_report", ProofOfAddressReport.class);
        mappings.put("us_driving_licence_report", UsDrivingLicenceReport.class);
        mappings.put("watchlist_aml_report", WatchlistAmlReport.class);
        mappings.put("watchlist_enhanced_report", WatchlistEnhancedReport.class);
        mappings.put("watchlist_peps_only_report", WatchlistPepsOnlyReport.class);
        mappings.put("watchlist_sanctions_only_report", WatchlistSanctionsOnlyReport.class);
        mappings.put("watchlist_standard_report", WatchlistStandardReport.class);
        mappings.put("report", Report.class);
        JSON.registerDiscriminator(Report.class, "name", mappings);
    }

    @Override
    public Map<String, GenericType> getSchemas() {
        return Report.schemas;
    }

    /**
     * Set the instance that matches the oneOf child schema, check
     * the instance parameter is valid against the oneOf child schemas:
     * DeviceIntelligenceReport, DocumentReport, DocumentVideoReport, DocumentVideoWithAddressInformationReport, DocumentWithAddressInformationReport, DocumentWithDriverVerificationReport, DocumentWithDrivingLicenceInformationReport, FacialSimilarityMotionReport, FacialSimilarityPhotoFullyAutoReport, FacialSimilarityPhotoReport, FacialSimilarityVideoReport, IdentityEnhancedReport, IndiaPanReport, KnownFacesReport, ProofOfAddressReport, UsDrivingLicenceReport, WatchlistAmlReport, WatchlistEnhancedReport, WatchlistPepsOnlyReport, WatchlistSanctionsOnlyReport, WatchlistStandardReport
     *
     * It could be an instance of the 'oneOf' schemas.
     * The oneOf child schemas may themselves be a composed schema (allOf, anyOf, oneOf).
     */
    @Override
    public void setActualInstance(Object instance) {
        if (JSON.isInstanceOf(DeviceIntelligenceReport.class, instance, new HashSet<>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(DocumentReport.class, instance, new HashSet<>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(DocumentVideoReport.class, instance, new HashSet<>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(DocumentVideoWithAddressInformationReport.class, instance, new HashSet<>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(DocumentWithAddressInformationReport.class, instance, new HashSet<>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(DocumentWithDriverVerificationReport.class, instance, new HashSet<>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(DocumentWithDrivingLicenceInformationReport.class, instance, new HashSet<>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(FacialSimilarityMotionReport.class, instance, new HashSet<>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(FacialSimilarityPhotoFullyAutoReport.class, instance, new HashSet<>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(FacialSimilarityPhotoReport.class, instance, new HashSet<>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(FacialSimilarityVideoReport.class, instance, new HashSet<>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(IdentityEnhancedReport.class, instance, new HashSet<>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(IndiaPanReport.class, instance, new HashSet<>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(KnownFacesReport.class, instance, new HashSet<>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ProofOfAddressReport.class, instance, new HashSet<>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(UsDrivingLicenceReport.class, instance, new HashSet<>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(WatchlistAmlReport.class, instance, new HashSet<>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(WatchlistEnhancedReport.class, instance, new HashSet<>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(WatchlistPepsOnlyReport.class, instance, new HashSet<>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(WatchlistSanctionsOnlyReport.class, instance, new HashSet<>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(WatchlistStandardReport.class, instance, new HashSet<>())) {
            super.setActualInstance(instance);
            return;
        }

        throw new RuntimeException("Invalid instance type. Must be DeviceIntelligenceReport, DocumentReport, DocumentVideoReport, DocumentVideoWithAddressInformationReport, DocumentWithAddressInformationReport, DocumentWithDriverVerificationReport, DocumentWithDrivingLicenceInformationReport, FacialSimilarityMotionReport, FacialSimilarityPhotoFullyAutoReport, FacialSimilarityPhotoReport, FacialSimilarityVideoReport, IdentityEnhancedReport, IndiaPanReport, KnownFacesReport, ProofOfAddressReport, UsDrivingLicenceReport, WatchlistAmlReport, WatchlistEnhancedReport, WatchlistPepsOnlyReport, WatchlistSanctionsOnlyReport, WatchlistStandardReport");
    }

    /**
     * Get the actual instance, which can be the following:
     * DeviceIntelligenceReport, DocumentReport, DocumentVideoReport, DocumentVideoWithAddressInformationReport, DocumentWithAddressInformationReport, DocumentWithDriverVerificationReport, DocumentWithDrivingLicenceInformationReport, FacialSimilarityMotionReport, FacialSimilarityPhotoFullyAutoReport, FacialSimilarityPhotoReport, FacialSimilarityVideoReport, IdentityEnhancedReport, IndiaPanReport, KnownFacesReport, ProofOfAddressReport, UsDrivingLicenceReport, WatchlistAmlReport, WatchlistEnhancedReport, WatchlistPepsOnlyReport, WatchlistSanctionsOnlyReport, WatchlistStandardReport
     *
     * @return The actual instance (DeviceIntelligenceReport, DocumentReport, DocumentVideoReport, DocumentVideoWithAddressInformationReport, DocumentWithAddressInformationReport, DocumentWithDriverVerificationReport, DocumentWithDrivingLicenceInformationReport, FacialSimilarityMotionReport, FacialSimilarityPhotoFullyAutoReport, FacialSimilarityPhotoReport, FacialSimilarityVideoReport, IdentityEnhancedReport, IndiaPanReport, KnownFacesReport, ProofOfAddressReport, UsDrivingLicenceReport, WatchlistAmlReport, WatchlistEnhancedReport, WatchlistPepsOnlyReport, WatchlistSanctionsOnlyReport, WatchlistStandardReport)
     */
    @Override
    public Object getActualInstance() {
        return super.getActualInstance();
    }

    /**
     * Get the actual instance of `DeviceIntelligenceReport`. If the actual instance is not `DeviceIntelligenceReport`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `DeviceIntelligenceReport`
     * @throws ClassCastException if the instance is not `DeviceIntelligenceReport`
     */
    public DeviceIntelligenceReport getDeviceIntelligenceReport() throws ClassCastException {
        return (DeviceIntelligenceReport)super.getActualInstance();
    }

    /**
     * Get the actual instance of `DocumentReport`. If the actual instance is not `DocumentReport`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `DocumentReport`
     * @throws ClassCastException if the instance is not `DocumentReport`
     */
    public DocumentReport getDocumentReport() throws ClassCastException {
        return (DocumentReport)super.getActualInstance();
    }

    /**
     * Get the actual instance of `DocumentVideoReport`. If the actual instance is not `DocumentVideoReport`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `DocumentVideoReport`
     * @throws ClassCastException if the instance is not `DocumentVideoReport`
     */
    public DocumentVideoReport getDocumentVideoReport() throws ClassCastException {
        return (DocumentVideoReport)super.getActualInstance();
    }

    /**
     * Get the actual instance of `DocumentVideoWithAddressInformationReport`. If the actual instance is not `DocumentVideoWithAddressInformationReport`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `DocumentVideoWithAddressInformationReport`
     * @throws ClassCastException if the instance is not `DocumentVideoWithAddressInformationReport`
     */
    public DocumentVideoWithAddressInformationReport getDocumentVideoWithAddressInformationReport() throws ClassCastException {
        return (DocumentVideoWithAddressInformationReport)super.getActualInstance();
    }

    /**
     * Get the actual instance of `DocumentWithAddressInformationReport`. If the actual instance is not `DocumentWithAddressInformationReport`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `DocumentWithAddressInformationReport`
     * @throws ClassCastException if the instance is not `DocumentWithAddressInformationReport`
     */
    public DocumentWithAddressInformationReport getDocumentWithAddressInformationReport() throws ClassCastException {
        return (DocumentWithAddressInformationReport)super.getActualInstance();
    }

    /**
     * Get the actual instance of `DocumentWithDriverVerificationReport`. If the actual instance is not `DocumentWithDriverVerificationReport`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `DocumentWithDriverVerificationReport`
     * @throws ClassCastException if the instance is not `DocumentWithDriverVerificationReport`
     */
    public DocumentWithDriverVerificationReport getDocumentWithDriverVerificationReport() throws ClassCastException {
        return (DocumentWithDriverVerificationReport)super.getActualInstance();
    }

    /**
     * Get the actual instance of `DocumentWithDrivingLicenceInformationReport`. If the actual instance is not `DocumentWithDrivingLicenceInformationReport`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `DocumentWithDrivingLicenceInformationReport`
     * @throws ClassCastException if the instance is not `DocumentWithDrivingLicenceInformationReport`
     */
    public DocumentWithDrivingLicenceInformationReport getDocumentWithDrivingLicenceInformationReport() throws ClassCastException {
        return (DocumentWithDrivingLicenceInformationReport)super.getActualInstance();
    }

    /**
     * Get the actual instance of `FacialSimilarityMotionReport`. If the actual instance is not `FacialSimilarityMotionReport`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `FacialSimilarityMotionReport`
     * @throws ClassCastException if the instance is not `FacialSimilarityMotionReport`
     */
    public FacialSimilarityMotionReport getFacialSimilarityMotionReport() throws ClassCastException {
        return (FacialSimilarityMotionReport)super.getActualInstance();
    }

    /**
     * Get the actual instance of `FacialSimilarityPhotoFullyAutoReport`. If the actual instance is not `FacialSimilarityPhotoFullyAutoReport`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `FacialSimilarityPhotoFullyAutoReport`
     * @throws ClassCastException if the instance is not `FacialSimilarityPhotoFullyAutoReport`
     */
    public FacialSimilarityPhotoFullyAutoReport getFacialSimilarityPhotoFullyAutoReport() throws ClassCastException {
        return (FacialSimilarityPhotoFullyAutoReport)super.getActualInstance();
    }

    /**
     * Get the actual instance of `FacialSimilarityPhotoReport`. If the actual instance is not `FacialSimilarityPhotoReport`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `FacialSimilarityPhotoReport`
     * @throws ClassCastException if the instance is not `FacialSimilarityPhotoReport`
     */
    public FacialSimilarityPhotoReport getFacialSimilarityPhotoReport() throws ClassCastException {
        return (FacialSimilarityPhotoReport)super.getActualInstance();
    }

    /**
     * Get the actual instance of `FacialSimilarityVideoReport`. If the actual instance is not `FacialSimilarityVideoReport`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `FacialSimilarityVideoReport`
     * @throws ClassCastException if the instance is not `FacialSimilarityVideoReport`
     */
    public FacialSimilarityVideoReport getFacialSimilarityVideoReport() throws ClassCastException {
        return (FacialSimilarityVideoReport)super.getActualInstance();
    }

    /**
     * Get the actual instance of `IdentityEnhancedReport`. If the actual instance is not `IdentityEnhancedReport`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `IdentityEnhancedReport`
     * @throws ClassCastException if the instance is not `IdentityEnhancedReport`
     */
    public IdentityEnhancedReport getIdentityEnhancedReport() throws ClassCastException {
        return (IdentityEnhancedReport)super.getActualInstance();
    }

    /**
     * Get the actual instance of `IndiaPanReport`. If the actual instance is not `IndiaPanReport`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `IndiaPanReport`
     * @throws ClassCastException if the instance is not `IndiaPanReport`
     */
    public IndiaPanReport getIndiaPanReport() throws ClassCastException {
        return (IndiaPanReport)super.getActualInstance();
    }

    /**
     * Get the actual instance of `KnownFacesReport`. If the actual instance is not `KnownFacesReport`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `KnownFacesReport`
     * @throws ClassCastException if the instance is not `KnownFacesReport`
     */
    public KnownFacesReport getKnownFacesReport() throws ClassCastException {
        return (KnownFacesReport)super.getActualInstance();
    }

    /**
     * Get the actual instance of `ProofOfAddressReport`. If the actual instance is not `ProofOfAddressReport`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ProofOfAddressReport`
     * @throws ClassCastException if the instance is not `ProofOfAddressReport`
     */
    public ProofOfAddressReport getProofOfAddressReport() throws ClassCastException {
        return (ProofOfAddressReport)super.getActualInstance();
    }

    /**
     * Get the actual instance of `UsDrivingLicenceReport`. If the actual instance is not `UsDrivingLicenceReport`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `UsDrivingLicenceReport`
     * @throws ClassCastException if the instance is not `UsDrivingLicenceReport`
     */
    public UsDrivingLicenceReport getUsDrivingLicenceReport() throws ClassCastException {
        return (UsDrivingLicenceReport)super.getActualInstance();
    }

    /**
     * Get the actual instance of `WatchlistAmlReport`. If the actual instance is not `WatchlistAmlReport`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `WatchlistAmlReport`
     * @throws ClassCastException if the instance is not `WatchlistAmlReport`
     */
    public WatchlistAmlReport getWatchlistAmlReport() throws ClassCastException {
        return (WatchlistAmlReport)super.getActualInstance();
    }

    /**
     * Get the actual instance of `WatchlistEnhancedReport`. If the actual instance is not `WatchlistEnhancedReport`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `WatchlistEnhancedReport`
     * @throws ClassCastException if the instance is not `WatchlistEnhancedReport`
     */
    public WatchlistEnhancedReport getWatchlistEnhancedReport() throws ClassCastException {
        return (WatchlistEnhancedReport)super.getActualInstance();
    }

    /**
     * Get the actual instance of `WatchlistPepsOnlyReport`. If the actual instance is not `WatchlistPepsOnlyReport`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `WatchlistPepsOnlyReport`
     * @throws ClassCastException if the instance is not `WatchlistPepsOnlyReport`
     */
    public WatchlistPepsOnlyReport getWatchlistPepsOnlyReport() throws ClassCastException {
        return (WatchlistPepsOnlyReport)super.getActualInstance();
    }

    /**
     * Get the actual instance of `WatchlistSanctionsOnlyReport`. If the actual instance is not `WatchlistSanctionsOnlyReport`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `WatchlistSanctionsOnlyReport`
     * @throws ClassCastException if the instance is not `WatchlistSanctionsOnlyReport`
     */
    public WatchlistSanctionsOnlyReport getWatchlistSanctionsOnlyReport() throws ClassCastException {
        return (WatchlistSanctionsOnlyReport)super.getActualInstance();
    }

    /**
     * Get the actual instance of `WatchlistStandardReport`. If the actual instance is not `WatchlistStandardReport`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `WatchlistStandardReport`
     * @throws ClassCastException if the instance is not `WatchlistStandardReport`
     */
    public WatchlistStandardReport getWatchlistStandardReport() throws ClassCastException {
        return (WatchlistStandardReport)super.getActualInstance();
    }

}

